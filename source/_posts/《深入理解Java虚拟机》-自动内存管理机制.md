---
title: 《深入理解Java虚拟机》---自动内存管理机制
date: 2016-08-21 11:08:22
tags: [读书笔记, JVM, 内存模型]
---
最近开始看《深入理解Java虚拟机_JVM高级特性与最佳实践》这本经典书籍，感觉不错，语言描述清晰，让人读着很舒服，确实是一本好书。感觉有些东西学了之后过不多久就会忘记，能够在学过之后写一下读书笔记，整理一下思路，在加深记忆的同时，也能够对这个知识点有更深层次的理解。
> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。

确实如作者所说，对于Java，我们不需要过分关注于它的内存管理细节，JVM为我们做了它能做的一切。可是，当我们对一个事物不甚了解时，我们又对它充满了好奇。但是，当我们真正像使用C++一样需要自己动手进行内存管理时，我们又对这其中的细节不胜其烦。同时，了解JVM的内存模型以及它的自动内存管理机制也是很有必要的。
<!-- more -->
## JVM运行时数据区分析
![jvm_memory](https://raw.githubusercontent.com/lirui1992/MarkdownPhotos/master/res/jvm_memory.png)
JVM运行时数据区包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。其中方法区和堆是线程共享的，另外三个则是线程私有的。
- 程序计数器：程序计数器是一块较小的内存，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值选取下一条需要执行的字节码指令。
程序计数器是线程私有的。如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
- Java虚拟机栈：与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。在Java虚拟机规范中，对于此区域规定了两种异常情况：
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
- 本地方法栈：本地方法栈与虚拟机所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。
- Java堆：对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
Java堆是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。
- 方法区：方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
- 运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。


## 对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
- 对象头：对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- 实例数据：实例数据部分是对象真正存储的有效信息。
- 对齐填充：对齐填充仅仅起着占位符的作用。




